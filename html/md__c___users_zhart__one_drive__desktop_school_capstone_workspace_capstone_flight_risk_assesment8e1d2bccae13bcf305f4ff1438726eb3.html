<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flight Risk Assessment: uncontrollable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Flight Risk Assessment
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">uncontrollable </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Wrap a controlled react component, to allow specific prop/handler pairs to be omitted by Component consumers. Uncontrollable allows you to write React components, with minimal state, and then wrap them in a component that will manage state for prop/handlers if they are excluded.</p>
<h1><a class="anchor" id="autotoc_md719"></a>
Install</h1>
<div class="fragment"><div class="line">npm i -S uncontrollable</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md720"></a>
Usage</h2>
<p>If you are a bit unsure on the <em>why</em> of this module read the next section first. If you just want to see some real-world examples, check out <a href="https://github.com/jquense/react-widgets">React Widgets</a> which makes <a href="https://github.com/jquense/react-widgets/blob/5d1b530cb094cdc72f577fe01abe4a02dd265400/src/Multiselect.jsx#L521">heavy use of this strategy</a>.</p>
<div class="fragment"><div class="line">import { uncontrollable } from &#39;uncontrollable&#39;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md721"></a>
API</h2>
<h3><a class="anchor" id="autotoc_md722"></a>
&lt;tt&gt;uncontrollable(Component, propHandlerHash, [methods])&lt;/tt&gt;</h3>
<ul>
<li><code>Component</code>: is a valid react component, such as the result of <code>createClass</code></li>
<li><code>propHandlerHash</code>: define the pairs of prop/handlers you want to be uncontrollable, e.g. &lsquo;{ value: 'onChange&rsquo;}<code> -</code>methods`: since uncontrollable wraps your component in another component, methods are not immediately accessible. You can proxy them through by providing the names of the methods you want to continue to expose. <b>You don't need this if you are using React &gt;= v16.3.0, the ref will automatically be forwarded to the uinderlying component</b></li>
</ul>
<p>For every prop you indicate as uncontrollable, the returned component will also accept an initial, <code>default</code> value for that prop. For example, <code>open</code> can be left uncontrolled but the initial value can be set via <code>defaultOpen={true}</code> if we want it to start open.</p>
<div class="fragment"><div class="line">import { uncontrollable } from &#39;uncontrollable&#39;</div>
<div class="line"> </div>
<div class="line">const UncontrolledCombobox = uncontrollable(Combobox, {</div>
<div class="line">  value: &#39;onChange&#39;,</div>
<div class="line">  open: &#39;onToggle&#39;,</div>
<div class="line">  searchTerm: &#39;onSearch&#39;, //the current typed value (maybe it filters the dropdown list)</div>
<div class="line">})</div>
</div><!-- fragment --><p>Since uncontrollable creates a new component that wraps your existing one, methods on your underlying component won't be immediately accessible. In general this sort of access is not idiomatic React, but it does have its place. The third argument of <code>uncontrollable()</code> is an optional array of method names you want uncontrollable to "pass through" to the original component.</p>
<div class="fragment"><div class="line">let UncontrolledForm = uncontrollable(Form, { value: &#39;onChange&#39; }, [&#39;submit&#39;])</div>
<div class="line"> </div>
<div class="line">//when you use a ref this will work</div>
<div class="line">this.refs.myForm.submit()</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md723"></a>
&lt;tt&gt;useUncontrolled(props, propsHandlerHash) =&gt; controlledProps&lt;/tt&gt;</h3>
<p>A React hook that can be used in place of the above Higher order Component. It returns a complete set of <code>props</code> which are safe to spread through to a child element.</p>
<div class="fragment"><div class="line">import { useUncontrolled } from &#39;uncontrollable&#39;</div>
<div class="line"> </div>
<div class="line">const UncontrolledCombobox = props =&gt; {</div>
<div class="line">  // filters out defaultValue, defaultOpen and returns controlled</div>
<div class="line">  // versions of onChange, and onToggle.</div>
<div class="line">  const controlledProps = useUncontrolled(props, {</div>
<div class="line">    value: &#39;onChange&#39;,</div>
<div class="line">    open: &#39;onToggle&#39;,</div>
<div class="line">  })</div>
<div class="line"> </div>
<div class="line">  return &lt;Checkbox {...controlledProps} /&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md724"></a>
Use Case</h2>
<p>One of the strengths of React is its extensibility model, enabled by a common practice of pushing component state as high up the tree as possible. While great for enabling extremely flexible and easy to reason about components, this can produce a lot of boilerplate to wire components up with every use. For simple components (like an input) this is usually a matter of tying the input <code>value</code> prop to a parent state property via its <code>onChange</code> handler. Here is an extremely common pattern:</p>
<div class="fragment"><div class="line">render() {</div>
<div class="line">  return (</div>
<div class="line">    &lt;input type=&#39;text&#39;</div>
<div class="line">      value={this.state.value}</div>
<div class="line">      onChange={ e =&gt; this.setState({ value: e.target.value })}</div>
<div class="line">    /&gt;</div>
<div class="line">  )</div>
<div class="line">}</div>
</div><!-- fragment --><p>This pattern moves the responsibility of managing the <code>value</code> from the input to its parent and mimics "two-way" databinding. Sometimes, however, there is no need for the parent to manage the input's state directly. In that case, all we want to do is set the initial <code>value</code> of the input and let the input manage it from then on. React deals with this through "uncontrolled" inputs, where if you don't indicate that you want to control the state of the input externally via a <code>value</code> prop it will just do the book-keeping for you.</p>
<p>This is a great pattern which we can make use of in our own Components. It is often best to build each component to be as stateless as possible, assuming that the parent will want to control everything that makes sense. Take a simple Dropdown component as an example</p>
<div class="fragment"><div class="line">class SimpleDropdown extends React.Component {</div>
<div class="line">  static propTypes = {</div>
<div class="line">    value: React.PropTypes.string,</div>
<div class="line">    onChange: React.PropTypes.func,</div>
<div class="line">    open: React.PropTypes.bool,</div>
<div class="line">    onToggle: React.PropTypes.func,</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  render() {</div>
<div class="line">    return (</div>
<div class="line">      &lt;div&gt;</div>
<div class="line">        &lt;input</div>
<div class="line">          value={this.props.value}</div>
<div class="line">          onChange={e =&gt; this.props.onChange(e.target.value)}</div>
<div class="line">        /&gt;</div>
<div class="line">        &lt;button onClick={e =&gt; this.props.onToggle(!this.props.open)}&gt;</div>
<div class="line">          open</div>
<div class="line">        &lt;/button&gt;</div>
<div class="line">        {this.props.open &amp;&amp; (</div>
<div class="line">          &lt;ul className=&quot;open&quot;&gt;</div>
<div class="line">            &lt;li&gt;option 1&lt;/li&gt;</div>
<div class="line">            &lt;li&gt;option 2&lt;/li&gt;</div>
<div class="line">          &lt;/ul&gt;</div>
<div class="line">        )}</div>
<div class="line">      &lt;/div&gt;</div>
<div class="line">    )</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Notice how we don't track any state in our simple dropdown? This is great because a consumer of our module will have the all the flexibility to decide what the behavior of the dropdown should be. Also notice our public API (propTypes), it consists of common pattern: a property we want set (<code>value</code>, <code>open</code>), and a set of handlers that indicate <em>when</em> we want them set (<code>onChange</code>, <code>onToggle</code>). It is up to the parent component to change the <code>value</code> and <code>open</code> props in response to the handlers.</p>
<p>While this pattern offers an excellent amount of flexibility to consumers, it also requires them to write a bunch of boilerplate code that probably won't change much from use to use. In all likelihood they will always want to set <code>open</code> in response to <code>onToggle</code>, and only in rare cases will want to override that behavior. This is where the controlled/uncontrolled pattern comes in.</p>
<p>We want to just handle the open/onToggle case ourselves if the consumer doesn't provide a <code>open</code> prop (indicating that they want to control it). Rather than complicating our dropdown component with all that logic, obscuring the business logic of our dropdown, we can add it later, by taking our dropdown and wrapping it inside another component that handles that for us.</p>
<p><code>uncontrollable</code> allows you separate out the logic necessary to create controlled/uncontrolled inputs letting you focus on creating a completely controlled input and wrapping it later. This tends to be a lot simpler to reason about as well.</p>
<div class="fragment"><div class="line">import { uncontrollable } from &#39;uncontrollable&#39;;</div>
<div class="line"> </div>
<div class="line">const UncontrollableDropdown = uncontrollable(SimpleDropdown, {</div>
<div class="line">  value: &#39;onChange&#39;,</div>
<div class="line">  open: &#39;onToggle&#39;</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">&lt;UncontrollableDropdown</div>
<div class="line">  value={this.state.val} // we can still control these props if we want</div>
<div class="line">  onChange={val =&gt; this.setState({ val })}</div>
<div class="line">  defaultOpen={true} /&gt; // or just let the UncontrollableDropdown handle it</div>
<div class="line">                        // and we just set an initial value (or leave it out completely)!</div>
</div><!-- fragment --><p>Now we don't need to worry about the open onToggle! The returned component will track <code>open</code> for us by assuming that it should just set <code>open</code> to whatever <code>onToggle</code> returns. If we <em>do</em> want to worry about it we can just provide <code>open</code> and <code>onToggle</code> props and the uncontrolled input will just pass them through.</p>
<p>The above is a contrived example but it allows you to wrap even more complex Components, giving you a lot of flexibility in the API you can offer a consumer of your Component. For every pair of prop/handlers you also get a defaultProp of the form "default[PropName]" so <code>value</code> -&gt; <code>defaultValue</code>, and <code>open</code> -&gt; <code>defaultOpen</code>, etc. <a href="https://github.com/jquense/react-widgets">React Widgets</a> makes heavy use of this strategy, you can see it in action here: <a href="https://github.com/jquense/react-widgets/blob/5d1b530cb094cdc72f577fe01abe4a02dd265400/src/Multiselect.jsx#L521">https://github.com/jquense/react-widgets/blob/5d1b530cb094cdc72f577fe01abe4a02dd265400/src/Multiselect.jsx#L521</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
